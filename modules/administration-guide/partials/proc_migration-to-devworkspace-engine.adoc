
[id="migration-to-devworkspace-engine_{context}"]
= Migration to {devworkspace} engine.

This procedure describes how to migration to {devworkspace} engine using https://docs.openshift.com/container-platform/latest/operators/understanding/olm/olm-understanding-olm.html[OLM] to support the Devfile 2.0.0 file format and mentions how to do so on existing instances.

.Prerequisites

* The `{orch-cli}` tool is available.
* An instance of {prod-short} deployed using xref:installation-guide:installing-che-on-openshift-4-using-operatorhub.adoc[Operator Hub] from `{prod-stable-channel}` channel on OpenShift cluster version greater or equal to 4.8
* OpenShift OAuth is enabled. See xref:configuring-openshift-oauth.adoc[].
* Bundled PostgreSQL

.Procedure

. All workspaces must be stopped and changes pushed back to Git repositories.

. Backup {prod-short} data. See xref:managing-backups-using-chectl.adoc[].

include::partial$snip_scaling-down-che.adoc[]

. Create the script to get all {prod-short} users:
+
[source,shell,subs="+attributes"]
----
cat >get-all-{prod-id}-users.sh<<EOF
#!/bin/bash
set -e

ALL_USERS_DUMP={prod-id}-users.txt
IDENTITY_PROVIDER_URL=\$({orch-cli} get checluster {prod-checluster} -n {prod-namespace} -o jsonpath="{.status.keycloakURL}" )
IDENTITY_PROVIDER_SECRET=\$({orch-cli} get checluster/{prod-checluster} -n {prod-namespace} -o jsonpath="{.spec.auth.identityProviderSecret}")
IDENTITY_PROVIDER_PASSWORD=\$(if [ -z "\$IDENTITY_PROVIDER_SECRET" ] || [ \$IDENTITY_PROVIDER_SECRET = "null" ]; then {orch-cli} get checluster/{prod-checluster}  -n {prod-namespace} -o jsonpath="{.spec.auth.identityProviderPassword}"; else {orch-cli} get secret \$IDENTITY_PROVIDER_SECRET -n {prod-namespace} -o jsonpath="{.data.password}" | base64 -d; fi)
IDENTITY_PROVIDER_USERNAME=\$(if [ -z "\$IDENTITY_PROVIDER_SECRET" ] || [ \$IDENTITY_PROVIDER_SECRET = "null" ]; then {orch-cli} get checluster/{prod-checluster}  -n {prod-namespace} -o jsonpath="{.spec.auth.IdentityProviderAdminUserName}"; else {orch-cli} get secret \$IDENTITY_PROVIDER_SECRET -n {prod-namespace} -o jsonpath="{.data.user}" | base64 -d; fi)
IDENTITY_PROVIDER_REALM=\$({orch-cli} get checluster {prod-checluster} -n {prod-namespace} -o jsonpath="{.spec.auth.identityProviderRealm}")

refreshToken() {
    IDENTITY_PROVIDER_TOKEN=\$(curl -ks \
    -d "client_id=admin-cli" \
    -d "username=\${IDENTITY_PROVIDER_USERNAME}" \
    -d "password=\${IDENTITY_PROVIDER_PASSWORD}" \
    -d "grant_type=password" \
    "\${IDENTITY_PROVIDER_URL}/realms/master/protocol/openid-connect/token" | jq -r ".access_token")
}

run() {
  rm -f \${ALL_USERS_DUMP}
  refreshToken
  ALL_USERS=\$(curl -ks  -H "Authorization: bearer \${IDENTITY_PROVIDER_TOKEN}" "\${IDENTITY_PROVIDER_URL}/\${IDENTITY_PROVIDER_USERNAME}/realms/\${IDENTITY_PROVIDER_REALM}/users")
  ALL_USERS_IDS=(\$(echo "\${ALL_USERS}" | jq ".[] | .id" | tr "\r\n" " "))

  for USER_ID in "\${ALL_USERS_IDS[@]}"; do
      refreshToken

      USER_ID=\$(echo "\${USER_ID}" | tr -d "\"")
      FEDERATED_IDENTITY=\$(curl -ks -H "Authorization: bearer \${IDENTITY_PROVIDER_TOKEN}" "\${IDENTITY_PROVIDER_URL}/\${IDENTITY_PROVIDER_USERNAME}/realms/\${IDENTITY_PROVIDER_REALM}/users/\${USER_ID}/federated-identity")
      IDENTITY_PROVIDER=\$(echo "\${FEDERATED_IDENTITY}" | jq -r ".[] | select(.identityProvider == \"openshift-v4\")")
      if [ -n "\${IDENTITY_PROVIDER}" ]; then
        USER_PROFILE=\$(echo "\${ALL_USERS}" | jq -r ".[] | select(.id == \"\${USER_ID}\")")
        USER_EMAIL=\$(echo "\${USER_PROFILE}" | jq -r ".email")
        USER_NAME=\$(echo "\${USER_PROFILE}" | jq -r ".username")
        USER_FIRST_NAME=\$(echo "\${USER_PROFILE}" | jq -r ".firstName")
        USER_LAST_NAME=\$(echo "\${USER_PROFILE}" | jq -r ".lastName")

        OPENSHIFT_USER_ID=\$(echo "\${IDENTITY_PROVIDER}" | jq ".userId" | tr -d "\"")
        echo "[INFO] Find {prod-short} user: \${USER_ID} and corresponding OpenShift user: \${OPENSHIFT_USER_ID}"
        echo "\${USER_ID} \${OPENSHIFT_USER_ID} username:\$(echo \${USER_NAME} | base64) email:\$(echo \${USER_EMAIL} | base64) firstName:\$(echo \${USER_FIRST_NAME} | base64) lastName:\$(echo \${USER_LAST_NAME} | base64) " >> \${ALL_USERS_DUMP}
      fi
  done
}

run
echo "[INFO] Done."
EOF

bash get-all-{prod-id}-users.sh
----

include::partial$snip_scaling-down-keycloak.adoc[]

include::partial$snip_finding-che-database-name.adoc[]

include::partial$snip_dumping-che-database.adoc[]

include::partial$snip_terminate-connections-to-postgresql-database.adoc[]

include::partial$snip_droping-che-database.adoc[]

include::partial$snip_creating-che-database.adoc[]

. Migrate {prod-short} users:
+
[subs="+quotes,+attributes"]
----
DUMP="che.sql"
ALL_USERS_DUMP={prod-id}-users.txt
while IFS= read -r line
do
  IDS=($line)
  USER_ID=${IDS[0]}
  OPENSHIFT_USER_ID=${IDS[1]}

  sed -i -e "s|${USER_ID}|${OPENSHIFT_USER_ID}|g" "${DUMP}"

  echo "[INFO] Migrated User ID from \"${USER_ID}\" to \"${OPENSHIFT_USER_ID}\""
done < "${ALL_USERS_DUMP}"
----

include::partial$snip_restoring-che-database.adoc[]

. Migrate users profiles:
+
[subs="+quotes,+attributes"]
----
ALL_USERS_DUMP={prod-id}-users.txt
while IFS= read -r line
do
  IDS=($line)
  OPENSHIFT_USER_ID=${IDS[1]}
  USER_NAME=$(echo ${IDS[2]} | cut -d ":" -f 2- | base64 -d)
  USER_EMAIL=$(echo ${IDS[3]} | cut -d ":" -f 2- | base64 -d)
  USER_FIRST_NAME=$(echo ${IDS[4]} | cut -d ":" -f 2- | base64 -d)
  USER_LAST_NAME=$(echo ${IDS[5]} | cut -d ":" -f 2- | base64 -d)

  {orch-cli} exec deploy/postgres -n {prod-namespace}  -- bash  -c "psql ${CHE_POSTGRES_DB} -tAc \"INSERT INTO profile(userid) VALUES ('${OPENSHIFT_USER_ID}');\""
  {orch-cli} exec deploy/postgres -n {prod-namespace}  -- bash  -c "psql ${CHE_POSTGRES_DB} -tAc \"INSERT INTO profile_attributes(user_id,name, value) VALUES ('${OPENSHIFT_USER_ID}', 'preferred_username', '${USER_NAME}');\""
  {orch-cli} exec deploy/postgres -n {prod-namespace}  -- bash  -c "psql ${CHE_POSTGRES_DB} -tAc \"INSERT INTO profile_attributes(user_id,name, value) VALUES ('${OPENSHIFT_USER_ID}', 'email', '${USER_EMAIL}');\""
  {orch-cli} exec deploy/postgres -n {prod-namespace}  -- bash  -c "psql ${CHE_POSTGRES_DB} -tAc \"INSERT INTO profile_attributes(user_id,name, value) VALUES ('${OPENSHIFT_USER_ID}', 'firstName', '${USER_FIRST_NAME}');\""
  {orch-cli} exec deploy/postgres -n {prod-namespace}  -- bash  -c "psql ${CHE_POSTGRES_DB} -tAc \"INSERT INTO profile_attributes(user_id,name, value) VALUES ('${OPENSHIFT_USER_ID}', 'lastName', '${USER_LAST_NAME}');\""

  echo "[INFO] Added profile for \"${OPENSHIFT_USER_ID}\""
done < "${ALL_USERS_DUMP}"
----

. Delete Cluster Service Version:
+
[subs="+quotes,+attributes"]
----
{orch-cli} delete csv $({orch-cli} get subscription {prod-id} -n {prod-namespace} -o jsonpath="{.status.currentCSV}") -n {prod-namespace}
----

. Delete Subscription:
+
[subs="+quotes,+attributes"]
----
{orch-cli} delete subscription {prod-id} -n {prod-namespace}
----

. Enable {devworkspace} engine:
+
[subs="+quotes,+attributes"]
----
{orch-cli} patch checluster/{prod-checluster} -n {prod-namespace} --type=json -p \
'[{"op": "replace", "path": "/spec/devWorkspace/enable", "value": true}]'
----

. Enable single-host exposure strategy:
+
[subs="+quotes,+attributes"]
----
{orch-cli} patch checluster/{prod-checluster} -n {prod-namespace} --type=json -p \
'[{"op": "replace", "path": "/spec/server/serverExposureStrategy", "value": "single-host"}]'
----

. Delete {identity-provider} route:
+
[subs="+quotes,+attributes"]
----
{orch-cli} delete route keycloak -n {prod-namespace}
----

. Delete {identity-provider} service:
+
[subs="+quotes,+attributes"]
----
{orch-cli} delete service keycloak -n {prod-namespace}
----

. Delete {identity-provider} deployment:
+
[subs="+quotes,+attributes"]
----
{orch-cli} delete deployment keycloak -n {prod-namespace}
----

ifeval::["{project-context}" == "che"]
. To deploy {prod} from `{prod-next-channel}` channel, create a catalog source:
+
[subs="+quotes,+attributes"]
----
{orch-cli} apply -f - <<EOF
apiVersion:  operators.coreos.com/v1alpha1
kind:         CatalogSource
metadata:
  name:         {prod-next-channel-catalog-source}
  namespace:    openshift-operators
spec:
  image:         {prod-next-channel-catalog-source-image}
  sourceType:  grpc
  updateStrategy:
    registryPoll:
      interval: 5m
EOF
----
endif::[]

. Create a new subscription:
+
ifeval::["{project-context}" == "che"]
To deploy from the `{prod-stable-channel}` channel:
+
endif::[]
[subs="+quotes,+attributes"]
----
{orch-cli} apply -f - <<EOF
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: {prod-id}
  namespace: openshift-operators
spec:
  channel: {prod-stable-channel}
  installPlanApproval: Automatic
  name: {prod-stable-channel-package}
  source: {prod-stable-channel-catalog-source}
  sourceNamespace: openshift-marketplace
EOF
----
+
ifeval::["{project-context}" == "che"]
To deploy from the `{prod-next-channel}` channel:
+
[subs="+quotes,+attributes"]
----
{orch-cli} apply -f - <<EOF
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: {prod-id}
  namespace: openshift-operators
spec:
  channel: {prod-next-channel}
  installPlanApproval: Automatic
  name: {prod-next-channel-package}
  source: {prod-next-channel-catalog-source}
  sourceNamespace: openshift-operators
EOF
----
endif::[]

. Wait until Operator is ready:
+
:k8s-component: {prod-operator}
:k8s-namespace: openshift-operators
include::partial$snip_waiting-for-component.adoc[]

. Wait until {prod-short} is ready:
+
:k8s-component: {prod-deployment}
:k8s-namespace: {prod-namespace}
include::partial$snip_waiting-for-component.adoc[]

include::partial$snip_verification-che-working.adoc[]
